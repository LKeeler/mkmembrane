#!/usr/bin/python3
# -*- coding: utf-8 -*-

__version__ = '0.2-r2'

from core import *
from copy import deepcopy
import numpy as np
import argparse
import sys
import random


def get_z_angle(vector, reference=[0, -1, 0]):
    '''Returns the angle between two vectors in the Z axis'''
    vector = np.array(vector[:2])
    reference = np.array(reference[:2])
    return np.arccos(np.dot(vector,
                            reference)
                     / (np.linalg.norm(vector) *
                        np.linalg.norm(reference)
                        )
                     )


def get_x_angle(vector, reference=[0, -1, 0]):
    '''Returns the angle between two vectors in the X axis'''
    vector = np.array(vector[1:])
    reference = np.array(reference[1:])
    return np.arccos(np.dot(vector,
                            reference)
                     / (np.linalg.norm(vector) *
                        np.linalg.norm(reference)
                        )
                     )


def align_residue(residue, reference=[0, -1, 0], threshold=1E-8):
    '''Aligns a residue to the Y axis'''
    # Aligning X axis
    xAxis = residue.get_cop()[0]
    while abs(xAxis) > threshold:
        zRotation = get_z_angle(residue.get_cop(), reference)
        residue.rotate(zRotation, 'Z')
        xAxis = residue.get_cop()[0]
        pass
    # Aligning Z axis
    zAxis = residue.get_cop()[2]
    while abs(zAxis) > threshold:
        xRotation = get_x_angle(residue.get_cop(), reference)
        residue.rotate(xRotation, 'X')
        zAxis = residue.get_cop()[2]
    pass
    return True


def center_residue(residue, head, center):
    for atom in residue.atoms:
        if (atom.name == head):
            selectedAtom = atom
            translation = atom.set_position(center)
            break
    else:
        return False
        for atom in residue.atoms:
            if (atom != selectedAtom):
                atom.translate(translation)
                pass
        pass
    return True


def create_shuffled_list(contents, amount):
    '''Creates a list of residues to put in the membrane, it requires a
    dictionary containing the filename of the residue and the content
    of it in percentage. Also requires de amount of residues in the membrane'''
    resultingList = []
    for residueFileName in contents:
        target = contents[residueFileName] * amount / 100
        amountAdded = 0
        while amountAdded < target:
            resultingList.append(residueFileName)
            amountAdded += 1
    random.shuffle(resultingList)
    return resultingList


def get_residue_size(residue):
    '''Returns the dimentions of an optimal box to contain the residue'''
    atomCoordinates = []
    for atom in residue.atoms:
        atomCoordinates.append(atom.position)
        pass
    xValues = []
    yValues = []
    zValues = []
    for coordinate in atomCoordinates:
        xValues.append(coordinate[0])
        yValues.append(coordinate[1])
        zValues.append(coordinate[2])
        pass
    xSize = max(xValues) - min(xValues)
    ySize = max(yValues) - min(yValues)
    zSize = max(zValues) - min(zValues)
    return [xSize, ySize, zSize]


def get_cell_size(residues):
    '''Calculates the optimal size of a cell (in X,Z coordinates)
    generated by a list of residues'''
    residueSizes = []
    for residue in residues:
        residueSizes.append(get_residue_size(residue))
        pass
    xValues = []
    yValues = []
    zValues = []
    for size in residueSizes:
        xValues.append(size[0])
        yValues.append(size[1])
        zValues.append(size[2])
        pass
    return [max(xValues) * 1.7, max(yValues), max(zValues) * 1.7]

WIDTH_X = 20
WIDTH_Z = 20

CONTENT = {}

# TODO: This shouldn't be hardcoded, must be parsed from an external file
HEAD_DATABASE = {'TTA': 'NAA',
                 'DOH': 'OAK'}


def main():
    # TODO: ask user for input
    # Create dictionary linking residue filename with its respective residue
    # instance
    residueDict = {}
    for residueFileName in CONTENT:
        scannedSystem = grohandler.readGro(residueFileName)
        # TODO: Check if the system scanned contains more than one residue
        scannedResidue = scannedSystem.residues[0]
        # Get head atom from database
        head = HEAD_DATABASE.get(scannedResidue.name)
        if head is None:
            errorhandler.error('Residue', residue.name, "doesn't have a"
                               "specified head in the database")
            return 2
        errorhandler.debug("Found head for", scannedResidue.name, ":", head)
        # Center head in the origin
        if center_residue(scannedResidue, head, [0, 0, 0]) is False:
            errorhandler.error("Could not center", scannedResidue.name)
            pass
        # Align head along Y axis
        align_residue(scannedResidue, [0, -1, 0])
        print(scannedResidue.get_cop())
        for atom in scannedResidue.atoms:
            print(atom.name, atom.position)
        residueDict[residueFileName] = scannedResidue
        pass
    # Set cell and membrane size
    residues = list(residueDict.values())
    cellSize = get_cell_size(residues)
    membraneSize = [cellSize[0] * WIDTH_X,
                    cellSize[1],
                    cellSize[2] + WIDTH_Z]
    membraneSystem = grohandler.GromacsSystem(title="Membrane generated by"
                                              " mkmembrane",
                                              dimentions=membraneSize)
    residuesPool = create_shuffled_list(CONTENT,
                                        amount=WIDTH_X * WIDTH_Z)
    # Start building the membrane
    for i in range(WIDTH_X):
        for j in range(WIDTH_Z):
            nextResidueFileName = residuesPool.pop()
            nextResidue = residueDict[nextResidueFileName]
            membraneSystem.add_residue(deepcopy(nextResidue))
            nextPosition = [(i + 1) * cellSize[0],
                            0,
                            (j + 1) * cellSize[2]]
            addedResidue = membraneSystem.residues[-1]
            addedResidue.translate(nextPosition)
            pass
        pass
    # Write the results to a file
    grohandler.writeGro(OUTPUT, membraneSystem)
    return 0

if __name__ == "__main__":
    sys.exit(main())
