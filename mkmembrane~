#!/usr/bin/python3
# -*- coding: utf-8 -*-

__version__ = '0.2-r2'

from core import *
import numpy as np
import argparse
import sys
import random


def get_z_angle(vector, reference=[0, -1, 0]):
    '''Returns the angle between two vectors in the Z axis'''
    vector = np.array(vector[:2])
    reference = np.array(reference[:2])
    return np.arccos(np.dot(vector,
                            reference)
                     / (np.linalg.norm(vector) *
                        np.linalg.norm(reference)
                        )
                     )


def get_x_angle(vector, reference=[0, -1, 0]):
    '''Returns the angle between two vectors in the X axis'''
    vector = np.array(vector[1:])
    reference = np.array(reference[1:])
    return np.arccos(np.dot(vector,
                            reference)
                     / (np.linalg.norm(vector) *
                        np.linalg.norm(reference)
                        )
                     )


def align_residue(residue, reference=[0, -1, 0], threshold=1E-8):
    '''Aligns a residue to the Y axis'''
    # Aligning X axis
    xAxis = residue.get_cop()[0]
    while abs(xAxis) > threshold:
        zRotation = get_z_angle(residue.get_cop(), reference)
        residue.rotate(zRotation, 'Z')
        xAxis = residue.get_cop()[0]
        pass
    # Aligning Z axis
    zAxis = residue.get_cop()[2]
    while abs(zAxis) > threshold:
        xRotation = get_x_angle(residue.get_cop(), reference)
        residue.rotate(xRotation, 'X')
        zAxis = residue.get_cop()[2]
    pass
    return True


def create_shuffled_list(contents, amount):
    '''Creates a list of residues to put in the membrane, it requires a
    dictionary containing the filename of the residue and the content
    of it in percentage. Also requires de amount of residues in the membrane'''
    resultingList = []
    for residueFileName in contents:
        target = contents[residueFileName] * amount / 100
        amountAdded = 0
        while amountAdded < target:
            resultingList.append(residueFileName)
            amountAdded += 1
    random.shuffle(resultingList)
    return resultingList


def get_residue_size(residue):
    '''Returns the dimentions of an optimal box to contain the residue'''
    atomCoordinates = []
    for atom in residue.atoms:
        atomCoordinates.append(atom.position)
        pass
    xValues = []
    yValues = []
    zValues = []
    for coordinate in atomCoordinates:
        xValues.append(coordinate[0])
        yValues.append(coordinate[1])
        zValues.append(coordinate[2])
        pass
    xSize = max(xValues) - min(xValues)
    ySize = max(yValues) - min(yValues)
    zSize = max(zValues) - min(zValues)
    return [xSize, ySize, zSize]


def get_cell_size(residues):
    '''Calculates the optimal size of a cell (in X,Z coordinates)
    generated by a list of residues'''
    residueSizes = []
    for residue in residues:
        residueSizes.append(get_residue_size(residue))
        pass
    xValues = []
    zValues = []
    for size in residueSizes:
        xValues.append(size[0])
        zValues.append(size[2])
        pass
    return [max(xValues), max(zValues)]

WIDTH_X = 10
WIDTH_Z = 10

CONTENT = {'decanol.gro': 15,
           'tta.gro': 85}

# TODO: This shouldn't be hardcoded, must be parsed from an external file
HEAD_DATABASE = {'TTA': 'NAA',
                 'DOH': 'OAK'}


def main():
    # TODO: preguntar por los residuos y sus porcentages
    residues = []
    for residueFileName in CONTENT:
        scannedSystem = grohandler.readGro(residueFileName)
        # TODO: Check if the system scanned contains more than one residue
        residues.append(scannedSystem.residues[0])
        pass
    for residue in residues:
        
    return 1


if __name__ == "__main__":
    sys.exit(main())
